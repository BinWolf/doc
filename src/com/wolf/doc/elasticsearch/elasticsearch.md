1、elasticsearch的启动：	elasticsearch-1.4.2/bin$ ./elasticsearch -d2、elasticsearch的关闭：	elasticsearch-1.4.2/bin$ curl -XPOST 'http://localhost:9200/_shutdown'3、安装Marvel	./bin/plugin -i elasticsearch/marvel/latest4、查看Marvel和sense：	如果你安装了Marvel（作为管理和监控的工具），就可以在浏览器里通过以下地址访问它：http://localhost:9200/_plugin/marvel/	你可以在Marvel中通过点击dashboards，在下拉菜单中访问Sense开发者控制台，或者直接访问以下地址：http://localhost:9200/_plugin/marvel/sense/5、创建索引员工查询5.1 添加员工信息：PUT /megacorp/employee/1	{    	"first_name" : "John",    	"last_name" :  "Smith",    	"age" :        25,    	"about" :      "I love to go rock climbing",    	"interests": [ "sports", "music" ]	}PUT /megacorp/employee/2	{   	"first_name" :  "Jane",    	"last_name" :   "Smith",    	"age" :         32,    	"about" :       "I like to collect rock albums",    	"interests":  [ "music" ]	}PUT /megacorp/employee/3	{    	"first_name" :  "Douglas",    	"last_name" :   "Fir",    	"age" :         35,    	"about":        "I like to build cabinets",    	"interests":  [ "forestry" ]	}5.2、搜索全部员工的请求：	GET /megacorp/employee/_search5.3、搜索姓氏中包含“Smith”的员工	GET /megacorp/employee/_search?q=last_name:Smith5.4、使用DSL语句查询GET /megacorp/employee/_search	{    	"query" : {        		"match" : {        		"last_name" : "Smith"        }}}5.5、找姓氏为“Smith”的员工并且年龄大于30岁的员工GET /megacorp/employee/_search{    "query" : {        "filtered" : {            "filter" : {                "range" : {                    "age" : { "gt" : 30 }                }            },            "query" : {                "match" : {                    "last_name" : "smith"                }            }        }    }}5.6、全文搜索GET /megacorp/employee/_search{    "query" : {        "match" : {            "about" : "rock climbing"        }    }}5.7、确切的匹配若干个单词或者短语(phrases)。例如查询同时包含"rock"和"climbing"（并且是相邻的）的员工记录：GET /megacorp/employee/_search{    "query" : {        "match_phrase" : {            "about" : "rock climbing"        }    }}5.8、搜索结果中高亮(highlight)匹配到的关键字：GET /megacorp/employee/_search{    "query" : {        "match_phrase" : {            "about" : "rock climbing"        }    },    "highlight": {        "fields" : {            "about" : {}        }    }}6、聚合（aggregations）6.1、找到所有职员中最大的共同点（兴趣爱好）是什么GET /megacorp/employee/_search{  "aggs": {    "all_interests": {      "terms": { "field": "interests" }    }  }}6.2、查找所有姓"Smith"的人最大的共同点（兴趣爱好）GET /megacorp/employee/_search{  "query": {    "match": {      "last_name": "smith"    }  },  "aggs": {    "all_interests": {      "terms": {        "field": "interests"      }    }  }}6.3、统计每种兴趣下职员的平均年龄：GET /megacorp/employee/_search{    "aggs" : {        "all_interests" : {            "terms" : { "field" : "interests" },            "aggs" : {                "avg_age" : {                    "avg" : { "field" : "age" }                }            }        }    }}7、集群7.1在一台机器上部署两个节点：1）复制一份配置好的节点elasticsearch-1.4.2为elasticsearch-1.4.2-node22）创建集群配置信息:elasticsearch-1.4.2配置# 配置集群名称cluster.name: liaobin# 配置节点名称node.name: 'es-node1'# 为节点之间的通信设置一个自定义端口(默认为9300)     transport.tcp.port: 9300 # 设置监听HTTP传输的自定义端(默认为9200)http.port: 9200 elasticsearch-1.4.2-node2配置# 配置集群名称cluster.name: liaobin# 配置节点名称node.name: 'es-node2'# 为节点之间的通信设置一个自定义端口(默认为9300)     transport.tcp.port: 9301 # 设置监听HTTP传输的自定义端(默认为9200)http.port: 9201   3）分别启动节点服务bin$ ./elasticsearch -d4）在浏览器查看是否启动成功http://localhost:9200/_plugin/head/ (对应节点1)http://localhost:9201/_plugin/head/ (对应节点2)7.2、在http://localhost:9200/_plugin/marvel/sense/index.html创建索引，分配3个主分片和一个复制分片：PUT /blogs{   "settings" : {      "number_of_shards" : 3,      "number_of_replicas" : 1   }}7.3、在http://localhost:9201/_plugin/head/中查看是否也有blogs索引，如果有就ok。8、全文搜索8.1、匹配查询PUT /my_index { "settings": 	{ "number_of_shards": 1 }}POST /my_index/my_type/_bulk { "index": { "_id": 1 }} { "title": "The quick brown fox" } { "index": { "_id": 2 }} { "title": "The quick brown fox jumps over the lazy dog" } { "index": { "_id": 3 }} { "title": "The quick brown fox jumps over the quick dog" } { "index": { "_id": 4 }}GET /my_index/my_type/_search { "query": { "match": { "title": "QUICK!" } }}8.1、多词查询GET /my_index/my_type/_search{    "query": {        "match": {            "title": "BROWN DOG!"        }    }}提高精度match查询接受一个operator参数，该参数的默认值是"or"。你可以将它改变为"and"来要求所有的词条都需要被匹配：GET /my_index/my_type/_search{    "query": {        "match": {            "title": {                      "query":    "BROWN DOG!",                "operator": "and"            }} }}控制精度(Controlling Precision)match查询支持minimum_should_match参数，它能够让你指定有多少词条必须被匹配才会让该文档被当做一个相关的文档。GET /my_index/my_type/_search{  "query": {    "match": {      "title": {        "query": "quick brown dog",        "minimum_should_match": "75%"      }    }  }}合并查询(Combining Queries)bool查询通过must，must_not以及should参数来接受多个查询。GET /my_index/my_type/_search{  "query": {    "bool": {      "must":     { "match": { "title": "quick" }},      "must_not": { "match": { "title": "lazy"  }},      "should": [                  { "match": { "title": "brown" }},                  { "match": { "title": "dog"   }}      ]    }  }}通过minimum_should_match参数来控制should语句需要匹配的数量，该参数可以是一个绝对数值或者一个百分比：GET /my_index/my_type/_search{  "query": {    "bool": {      "should": [        { "match": { "title": "brown" }},        { "match": { "title": "fox"   }},        { "match": { "title": "dog"   }}      ],      "minimum_should_match": 2     }  }}最佳字段查询及其调优PUT /my_index/my_type/1{    "title": "Quick brown rabbits",    "body":  "Brown rabbits are commonly seen."}PUT /my_index/my_type/2{    "title": "Keeping pets healthy",    "body":  "My quick brown fox eats rabbits on a regular basis."}GET /my_index/my_type/_search{    "query": {        "bool": {            "should": [                { "match": { "title": "Brown fox" }},                { "match": { "body":  "Brown fox" }}            ]        }    }}dis_max查询GET /my_index/my_type/_search{    "query": {        "dis_max": {            "queries": [                { "match": { "title": "Brown fox" }},                { "match": { "body":  "Brown fox" }}            ]        }    }}tie_breaker将其它匹配的查询子句考虑进来也是可能的。通过指定tie_breaker参数：GET /my_index/my_type/_search{    "query": {        "dis_max": {            "queries": [                { "match": { "title": "Quick pets" }},                { "match": { "body":  "Quick pets" }}            ],            "tie_breaker": 0.3        }    }}multi_match查询默认情况下，该查询以best_fields类型执行，它会为每个字段生成一个match查询，然后将这些查询包含在一个dis_max查询中。下面的dis_max查询：GET /my_index/my_type/_search{  "dis_max": {    "queries":  [      {        "match": {          "title": {            "query": "Quick brown fox",            "minimum_should_match": "30%"          }        }      },      {        "match": {          "body": {            "query": "Quick brown fox",            "minimum_should_match": "30%"          }        }      },    ],    "tie_breaker": 0.3  }}可以通过multi_match简单地重写如下：GET /my_index/my_type/_search{    "multi_match": {        "query":                "Quick brown fox",        "type":                 "best_fields",         "fields":               [ "title", "body" ],        "tie_breaker":          0.3,        "minimum_should_match": "30%"     }}在字段名中使用通配符GET /my_index/my_type/_search{    "multi_match": {        "query":  "Quick brown fox",        "fields": "*_title"    }}提升个别字段GET /my_index/my_type/_search{    "multi_match": {        "query":  "Quick brown fox",        "fields": [ "*_title", "chapter_title^2" ]     }}chapter_title字段的boost值为2，而book_title和section_title字段的boost值为默认的1。多字段映射(Multifield Mapping)DELETE /my_indexPUT /my_index{    "settings": { "number_of_shards": 1 },     "mappings": {        "my_type": {            "properties": {                "title": {                     "type":     "string",                    "analyzer": "english",                    "fields": {                        "std":   {                             "type":     "string",                            "analyzer": "standard"                        }                    }                }            }        }    }}PUT /my_index/my_type/1{ "title": "My rabbit jumps" }PUT /my_index/my_type/2{ "title": "Jumping jack rabbits" }GET /my_index/_search{   "query": {        "multi_match": {            "query":  "jumping rabbits",            "type":   "most_fields",             "fields": [ "title", "title.std" ]        }    }}提升title字段来让该字段更加重要，这也减小了其它信号字段的影响：GET /my_index/_search{   "query": {        "multi_match": {            "query":       "jumping rabbits",            "type":        "most_fields",            "fields":      [ "title^10", "title.std" ]         }    }}跨字段实体搜索(Cross-fields Entity Search){    "query": {        "multi_match": {            "query":       "Poland Street W1V",            "type":        "most_fields",            "operator":    "and",             "fields":      [ "street", "city", "country", "postcode" ]        }    }}前缀查询(Prefix Query)GET /my_index/address/_search{    "query": {        "prefix": {            "field": "keyword"        }    }}prefix查询是一个工作在词条级别的低级查询。原理：它会变了所有文档对应的字段是否符合并逐个收集符合记录id。如果数据量大操作非常慢。通配符查询（wildcard Query）wildcard查询是一个基于词条的低级别查询，它使用标准的shell通配符：?用来匹配任意字符，*用来匹配零个或者多个字符。GET /my_index/address/_search{    "query": {        "wildcard": {            "field": "W?F*HW"         }    }}正则表达式查询（regexp Query）GET /my_index/address/_search{    "query": {        "regexp": {            "field": "W[0-9].+"         }    }}这个正则表达式的规定了词条需要以W开头，紧跟着一个0到9的数字，然后是一个或者多个其它字符。邻近匹配(Proximity Matching)创建索引PUT /my_index { "settings": { ... any settings ... },"mappings": { "type_one": { ... any mappings ... }, "type_two": { ... any mappings ... }, ...} }删除索引DELETE /my_index 删除多个索引DELETE /index_one,index_twoDELETE /index_* 删除所有索引DELETE /_all 索引设置PUT /my_temp_index { "settings": { "number_of_shards" : 1, "number_of_replicas" : 0 } } 主分片的数量创建后不能改变，复制分片数量创建后可以修改。修改复制分片：PUT /my_temp_index/_settings { "number_of_replicas": 1 } 自定义分析器1、用html_strip 字符过滤器去除所以的HTML标签 2、将&替换成and，使用一个自定义的mapping字符过滤器3、使用standard 分词器分割单词4、使用lowercase 表征过滤器5、用 stop 表征过滤器去除一些自定义停用词PUT /my_index{  "settings": {    "analysis": {      "char_filter": {        "&_to_and":{          "type":"mapping",          "mappings":["&=> and "]        }      },      "filter": {        "my_stopwords":{          "type":"stop",          "stopwords":["the","a","is"]        }      },      "analyzer": {        "my_analyzer":{          "type":"custom",          "char_filter":["html_strip","&_to_and"],          "tokenizer":"standard",          "filter":["lowercase","my_stopwords"]        }      }    }  }}别名的作用之一：零停机时间内从旧的索引切换到新的索引。创建别名：put /my_index_v1			//创建一个indexput /my_index_v1/_alias/my_index		//给my_index_v1起一个别名检测这个别名指向哪个索引：GET /*/_alias/my_index检测哪些别名指向这个索引：GET /my_index_v1/_alias/*下面例子利用别名实现修改映射：创建一个新的索引并且添加映射：PUT /my_index_v2{  "mappings": {    "my_type":{      "properties": {        "tags":{          "type": "string",          "index": "not_analyzed"        }      }    }  }}修改别名的指向：POST /_aliases{  "actions": [    {"remove": {"index": "my_index_v1","alias": "my_index"}},    {"add": {"index": "my_index_v2","alias": "my_index"}}  ]}结构化搜索批量插入：POST /my_store/products/_bulk{"index":{"_id":1}}{"price":10,"productID":"XHDK-A-1293-#fJ3"}{"index":{"_id":2}}{"price":20,"productID":"KDKE-B-9947-#kL5"}{"index":{"_id":3}}{"price":30,"productID":"JODL-X-1937-#pV7"}{"index":{"_id":4}}{"price":30,"productID":"QQPX-R-3956-#aD8"}term过滤器：GET /my_store/products/_search{  "query": {    "filtered": {      "filter": {        "term": {"price": "20"}      }}}}组合过滤器，bool过滤器：GET /my_store/products/_search{  "query": {    "filtered": {      "filter": {        "bool": {          "should": [            {"term": {"price": 20}},            {"term": {"productID": "XHDK-A-1293-#fJ3"}}          ],          "must_not":{            "term": {"price": 30}}        }      }    }  }}相当于：select * from products where (price = 20 OR productID = "XHDK-A-1293-#fJ3")  AND  (price != 30) bool 过滤器由三部分组成：{	"bool": {          "should": [],          "must":[],  "must_not":[]}}must:所有分句都必须匹配，与and相同，must_not：所有的分句都必须不匹配，与not相同，should:至少有一个分句匹配，与or相同。嵌套布尔过滤器：GET /my_store/products/_search{  "query": {    "filtered": {      "filter": {        "bool": {          "should": [            {"term": {"productID" : "KDKE-B-9947-#kL5"}},            {"bool": {              "must": [                {"term": {"productID" : "JODL-X-1937-#pV7"}},                {"term": {"price" : 30}}              ]            }}          ]        }      }    }  }}相当于：SELECT * FROM products WHERE productID = "KDKE-B-9947-#kL5" OR ( productID = "JODL-X-1937-#pV7" AND price = 30 ) 查询多个准确值：termsGET /my_store/products/_search{  "query": {    "filtered": {      "filter": {        "terms": {          "price": [10,20]        }      }    }  }}term 是必须包含的操作不是必须相等的操作。完全匹配GET /my_index/my_type/_search{  "query": {    "filtered": {      "filter": {        "bool": {          "must": [            {"term": {"tags": "search"}},            {"term": {"tag_count": 1}}          ]        }      }    }  }}范围查询： range过滤器GET /my_store/products/_search{  "query": {    "filtered": {      "filter": {        "range": {          "price": {"gt": 20,"lt": 40}}      }    }  }}exists 过滤器处理null批量插入数据：POST /my_index/posts/_bulk{"index":{"_id":"1"}}{"tags":["search"]}{"index":{"_id":"2"}}{"tags":["search","open_source"]}{"index":{"_id":"3"}}{"other_field" : "some data"}{"index":{"_id":"4"}}{"tags":null}{"index":{"_id":"5"}}{"tags":["search",null]}检测tags字段是否为空：GET /my_index/posts/_search{  "query": {    "filtered": {      "filter": {"exists": {"field": "tags"}}    }  }}相当于：select tags from posts where tags in not nullmissing 过滤器，判断为空,与exists相反GET /my_index/posts/_search{  "query": {    "filtered": {      "filter": {"missing": {"field": "tags"}}    }  }}相当于：select tags from posts where tags in null全文搜索：DELETE /my_indexPUT /my_index{ "settings": { "number_of_shards": 1 }}POST /my_index/my_type/_bulk{ "index": { "_id": 1 }}{ "title": "The quick brown fox" }{ "index": { "_id": 2 }}{ "title": "The quick brown fox jumps over the lazy dog" }{ "index": { "_id": 3 }}{ "title": "The quick brown fox jumps over the quick dog" }{ "index": { "_id": 4 }}{ "title": "Brown fox brown dog" }查询quick：GET /my_index/my_type/_search{    "query": {        "match": {"title": "QUICK!"}    }}多词查询：GET /my_index/my_type/_search{    "query": {        "match": {"title": "BROWN DOG!"}    }}提高精确度：GET /my_index/my_type/_search{    "query": {        "match": {            "title": {                     "query":    "BROWN DOG!",                "operator": "and"            }        }    }}operator参数 值有两种and和or ，默认就是or。minimum_should_match参数表示必须满足搜索关键词的比例：GET /my_index/my_type/_search{  "query": {    "match": {      "title": {        "query":"quick brown dog",        "minimum_should_match": "75%"      }    }  }}组合查询：单bool实现：GET /my_index/my_type/_search {   "query": {     "bool": {       "must": { "match": { "title": "quick" }},       "must_not": { "match": { "title": "lazy" }},      "should": [         { "match": { "title": "brown" }},         { "match": { "title": "dog" }}         ]     }   }}bool+ minimum_should_matchGET /my_index/my_type/_search {   "query": {     "bool": {       "should": [         { "match": { "title": "brown" }},         { "match": { "title": "fox" }},         { "match": { "title": "dog" }}         ],         "minimum_should_match": 3  } }}minimum_should_match：3表示必须满足3个。跨字段实体搜索(Cross-fields Entity Search)GET /my_index/my_type /_search{  "query": {    "bool": {      "should": [        { "match": { "street":    "Poland Street W1V" }},        { "match": { "city":      "Poland Street W1V" }},        { "match": { "country":   "Poland Street W1V" }},        { "match": { "postcode":  "Poland Street W1V" }}      ]    }  }}使用multi_match查询替代上例子：GET /my_index/my_type/_search{  "query": {    "multi_match": {      "query":       "Poland Street W1V",      "type":        "most_fields",      "fields":      [ "street", "city", "country", "postcode" ]    }  }}